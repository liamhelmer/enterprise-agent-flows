#!/usr/bin/env bash
# Create draft PR from session state
#
# This script creates a draft pull request with:
# - AI-generated plain English summary
# - Agent contributions with what they did and why
# - Original user prompt for reference

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
STATE_DIR="${FORK_JOIN_STATE_DIR:-.fork-join}"

# Source common utilities for claude_fast_call
if [[ -f "${SCRIPT_DIR}/../hooks/lib/common.sh" ]]; then
	source "${SCRIPT_DIR}/../hooks/lib/common.sh"
fi

# Arguments
SESSION_ID="${1:-}"

# Generate AI summary of the PR
generate_ai_summary() {
	local prompt="$1"
	local agent_work="$2"
	local commit_log="$3"

	local sanitized_prompt
	sanitized_prompt=$(echo "$prompt" | tr '\n' ' ' | head -c 800)
	local sanitized_agents
	sanitized_agents=$(echo "$agent_work" | head -c 1000)

	local ai_prompt="Generate a PR description for multi-agent work.

ORIGINAL TASK:
${sanitized_prompt}

AGENT CONTRIBUTIONS:
${sanitized_agents}

Generate a description with:
1. **Summary**: 2-3 sentences describing the task in plain English
2. **What Was Done**: Brief description of what each agent accomplished
3. **Why**: Explanation of why these changes were needed

Be concise and professional. Output only the description."

	export FORK_JOIN_HOOK_CONTEXT=1
	local summary=""
	# Use claude_fast_call if available, otherwise fall back to direct call
	if type claude_fast_call &>/dev/null; then
		summary=$(claude_fast_call "$ai_prompt" 15)
	elif command -v claude >/dev/null 2>&1; then
		if command -v timeout >/dev/null 2>&1; then
			summary=$(echo "$ai_prompt" | timeout 15 claude --print --model haiku -p - 2>/dev/null) || true
		elif command -v gtimeout >/dev/null 2>&1; then
			summary=$(echo "$ai_prompt" | gtimeout 15 claude --print --model haiku -p - 2>/dev/null) || true
		fi
	fi
	unset FORK_JOIN_HOOK_CONTEXT

	if [[ -n "$summary" ]]; then
		echo "$summary"
		return 0
	fi
	return 1
}

main() {
	if [[ -z "$SESSION_ID" ]]; then
		# Try to get current session
		if [[ -f "${STATE_DIR}/current_session" ]]; then
			SESSION_ID="$(cat "${STATE_DIR}/current_session")"
		else
			echo "Usage: $0 <session-id>" >&2
			exit 1
		fi
	fi

	local session_file="${STATE_DIR}/${SESSION_ID}.json"
	if [[ ! -f "$session_file" ]]; then
		echo "Session file not found: $session_file" >&2
		exit 1
	fi

	# Extract session data
	local feature_branch base_branch original_prompt
	feature_branch="$(jq -r '.feature_branch' "$session_file")"
	base_branch="$(jq -r '.base_branch' "$session_file")"
	# The prompt is stored as "prompt" in the session state (not "original_prompt")
	original_prompt="$(jq -r '.prompt // empty' "$session_file")"

	# Get agent commits
	local agents_json
	agents_json="$(jq -r '.agents | map(select(.commit_message != null))' "$session_file")"
	local agent_count
	agent_count=$(echo "$agents_json" | jq -r 'length')

	# Format agent contributions for display
	local agent_contributions
	agent_contributions=$(echo "$agents_json" | jq -r '.[] | "- **\(.agent_id)** (\(.agent_type // "worker")): \(.commit_message)"')

	# Get commit log
	local commit_log
	commit_log=$(git log "${base_branch}..${feature_branch}" --oneline 2>/dev/null || echo "")

	# Generate PR title from branch name (more reliable than prompt)
	local pr_title
	local branch_desc
	branch_desc=$(echo "$feature_branch" | sed 's/^[^/]*\///' | tr '-' ' ')
	pr_title="${branch_desc}"
	if [[ ${#pr_title} -gt 72 ]]; then
		pr_title="${pr_title:0:69}..."
	fi

	# Try to generate AI summary
	local ai_summary=""
	if [[ -n "$original_prompt" ]]; then
		ai_summary=$(generate_ai_summary "$original_prompt" "$agent_contributions" "$commit_log") || true
	fi

	# Generate PR body
	local pr_body
	if [[ -n "$ai_summary" ]]; then
		pr_body="${ai_summary}"
	else
		# Fallback: structured format without AI
		pr_body="## Summary

${original_prompt:-No task description available}

## Agent Contributions

${agent_contributions:-No agent contributions recorded}"
	fi

	# Generate timestamp for this prompt
	local prompt_timestamp
	prompt_timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

	# Append metadata
	pr_body="${pr_body}

---

## Metadata

| Field | Value |
|-------|-------|
| Agents | ${agent_count} |
| Commits | $(echo "$commit_log" | wc -l | tr -d ' ') |
| Branch | \`${feature_branch}\` |

<details>
<summary>Commit History</summary>

\`\`\`
${commit_log:-No commits}
\`\`\`

</details>

---

## Prompt History

<details>
<summary>üìù Prompt - ${prompt_timestamp}</summary>

\`\`\`
${original_prompt:-No prompt recorded}
\`\`\`

</details>

*Generated by Agent Fork-Join*"

	# Push branch if needed
	if ! git ls-remote --heads origin "$feature_branch" | grep -q "$feature_branch"; then
		echo "Pushing branch to remote..."
		git push -u origin "$feature_branch"
	fi

	# Create PR using gh CLI
	local pr_url
	pr_url="$(gh pr create \
		--base "$base_branch" \
		--head "$feature_branch" \
		--title "$pr_title" \
		--body "$pr_body" \
		--draft \
		--label "ai-generated" \
		2>&1)"

	local pr_number
	pr_number="$(echo "$pr_url" | grep -oE '[0-9]+$' || echo "")"

	# Update session state with PR number
	if [[ -n "$pr_number" ]]; then
		jq --arg num "$pr_number" --arg url "$pr_url" \
			'.pr_number = ($num | tonumber) | .pr_url = $url | .state = "PR_CREATED"' \
			"$session_file" >"${session_file}.tmp" && mv "${session_file}.tmp" "$session_file"
	fi

	# Output result
	cat <<EOF
{
    "pr_created": true,
    "pr_number": ${pr_number:-null},
    "pr_url": "${pr_url}",
    "feature_branch": "${feature_branch}",
    "base_branch": "${base_branch}"
}
EOF
}

main "$@"
